# Mike Xie

## The missionary and cannibals problem is stated as follows. Three missionaries
## and three cannibals are on one side of the river, 
## along with a boat that can hold one or two people.
## find a way to get everyone to the other side
## without ever leaving a group of missionaries outnumbered by cannibals in that place


## formulate the search problem formally. State clearly how you represent states,
## (include the inital state and the goals state), what actions are available
## in each state, including the cost of each action.


## sketch a solution of the problem, show the path and its cost.
## describe the search strategy that you have used and motivate it

## implement search strategies in the AIMA code

## provide the path to the solution generated by your code
## uniform-cost search
## iterative deepening search
## greedy-best-first search
## A* search
## recursive best-first search


'''
Initial State
M3 M0
C3 C0
3 3 0 0
'''

'''
Goal State
M0 M3
C0 C3
0 0 3 3
'''

## missionary and cannibal initial state is that they are all on west side
initial = [[3, 3], [0, 0]]
## missionary and cannibal goal state is that they are all on east side
goal = [[0 ,0],[3, 3]]

## Heurisitcs

# Manhattan Distance: - For this problem, Manhattan distance is defined as
# the distance of a tile from its global state
# for every missionary and cannibal that is out of place, it is the Manhattan distance
# the inital manhattan distance is 6. Since we start off with 3 Missionary and 3 Cannibals out of place

# The Heuristics for Missionary and Cannibal problem
import sys
from collections import deque
import math
import heapq

# problems will be solved with various search algorithms
class Problem(object):
	def __init__(self, initial, goal=None):
		self.initial = initial
		self.goal = goal
	def actions(self, state):
		raise NotImplementedError
	def result(self, state, action):
		raise NotImplementedError
	# check if state is a goal
	def goal_test(self, state):
		if isinstance(self.goal, list):
			return is_in(state, self.goal)
		else:
			return state == self.goal
	#cost increase for every step in path
	def path_cost(self, c, state1, action, state2):
		return c + 1
	def value(self, state):
		raise NotImplementedError
class Node:
	def __init__(self, state, parent=None, action=None, path_cost=0):
		# Create a search tree node, made from parent from an action
		self.state = state
		self.parent = parent
		self.action = action
		self.path_cost = path_cost
		self.depth = 0
		if parent:
			self.depth = parent.depth + 1
	def __repr__(self):
		return "<Node {}>".format(self.state)
	def __lt__(self, node):
		return self.state < node.state
	def expand(self, problem):
		# list the nodes reachable in one step from this node
		return [self.child_node(problem, action)
			for action in problem.actions(self.state)]
	def child_node(self, problem, action):
		next_state = problem.result(self.state, action)
		next_node = Node(next_state, self, action, problem.path_cost(self.path_cost, self.state, action, next_state))
		return next_node
	def solution(self):
		# return the sequence of actions to go from the root to this node
		return [node.action for node in self.path()[1:]]
	def path(self):
		# the path of a node
		node, path_back = self, []
		while node:
			path_back.append(node)
			node = node.parent
		return list(reversed(path_back))
	def __eq__(self, other):
		return isinstance(other, Node) and self.state == other.state
	def __hash__(self):
		return hash(self.state)

class MissionaryCannibal(Problem):
	def __init__(self, initial, goal):
		Problem.__init__(self, initial, goal)
		self.state = initial
	def action(self, state):
		# list of possible actions
		# boat is on Right side
		if(state[2]==1):
			# if there are 3 missionaries on the right side
			if state[0]==3: 
				# if there are 2 or more cannibals on the right side
				if state[1]>=2:
				# possible actions
					return ["MM","M","MC","C","CC"]
				elif state[1]==1:
					return ["MM","M","MC","C"]
				# no cannibals
				else:
					return ["MM","M"]
			# 2 missionaries
			elif (state[0]==2):
				if state[1]==2:
					return ["MM","M","MC","C","CC"]
				else:
					return []
			# 1 missionaries
			elif (state[0]==1):
				if state[1]==1:
					return ["M", "MC", "C"]
				else:
					return []
			# 0 missionaries
			else: 
				if state[1]>=2:
					return ["C", "CC"]
				else:
					return ["C"]
		# boat is on the left side
		elif(state[2] == 0):
			# 3 missionaries
			if (state[0]==3):
				# 2 cannibals
				if(state[1]==2):
					return ["C"]
				else:
					return ["C","CC"]
			elif state[0]==2:
				if state[1]==2:
					return ["M","MC","C"]
				else:
					return []
			elif state[0]==1:
				if state[1]==1:
					return ["MM","M", "MC", "C", "CC"]
				else:
					return []
			else:
				if state[1]==3:
					return ["M","MM"]
				elif state[1]==2:
					return ["M","MM","MC","C"]
				else:
					return ["M","MM","MC","CC"]
		else:
			return None

	def result(self, state, action):
		state = list(state)
		# boat on right side
		if state[2]==1:
			# boat now on left side
			state[2]=0
			if action=="M":
				state[0]=state[0]-1
			elif action=="MM":
				state[0]=state[0]-2
			elif action=="MC":
				state[0]=state[0]-1
				state[1]=state[1]-1
			elif action=="C":
				state[1]=state[1]-1
			else:
				state[1]=state[1]-2
		# boat on left side
		else:
			state[2]=1
			if action=="M":
				state[0]=state[0]+1
			elif action=="MM":
				state[0]=state[0]+2
			elif action=="MC":
				state[0]=state[0]+1
				state[1]=state[1]+1
			elif action=="C":
				state[1]=state[1]+1
			else:
				state[1]=state[1]+2
		self.state=state
		return self.state

	# Check if current state is goal or not
	def goalTest(self, state):
		if state == self.goal:
			return True
		else:
			return False


def main():
	print("hi")
	initial = [3,3,1]
	goal = [0,0,0]
	
	mcproblem = MissionaryCannibal(initial, goal)
	#uniform cost
	#iterative deepening
	#greedy best first search
	#A* search
	#recursive best first search
	s=uniform_cost_search(mcproblem)
	
	
main()
