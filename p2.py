# Mike Xie

## The missionary and cannibals problem is stated as follows. Three missionaries
## and three cannibals are on one side of the river, 
## along with a boat that can hold one or two people.
## find a way to get everyone to the other side
## without ever leaving a group of missionaries outnumbered by cannibals in that place


## formulate the search problem formally. State clearly how you represent states,
## (include the inital state and the goals state), what actions are available
## in each state, including the cost of each action.


## sketch a solution of the problem, show the path and its cost.
## describe the search strategy that you have used and motivate it

## implement search strategies in the AIMA code

## provide the path to the solution generated by your code
## uniform-cost search
## iterative deepening search
## greedy-best-first search
## A* search
## recursive best-first search


'''
Initial State
M3 M0
C3 C0
3 3 0 0
'''

'''
Goal State
M0 M3
C0 C3
0 0 3 3
'''

## Heurisitcs

# Manhattan Distance: - For this problem, Manhattan distance is defined as
# the distance of a tile from its global state
# for every missionary and cannibal that is out of place, it is the Manhattan distance
# the inital manhattan distance is 6. Since we start off with 3 Missionary and 3 Cannibals out of place

# The Heuristics for Missionary and Cannibal problem

from utils import *
from search import *


# problems will be solved with various search algorithms
class MissionaryCannibal(Problem):
	def __init__(self, initial, goal):
		Problem.__init__(self, initial, goal)
		self.state = initial
		
	def actions(self, state):
		# list of possible actions
		# boat is on Right side
		if(state[2]==1):
			# if there are 3 missionaries on the right side
			if state[0]==3: 
				# if there are 2 or more cannibals on the right side
				if state[1]>=2:
				# possible actions
					return ["MM","M","MC","C","CC"]
				elif state[1]==1:
					return ["MM","M","MC","C"]
				# no cannibals
				else:
					return ["MM","M"]
			# 2 missionaries
			elif (state[0]==2):
				if state[1]==2:
					return ["MM","M","MC","C","CC"]
				else:
					return []
			# 1 missionaries
			elif (state[0]==1):
				if state[1]==1:
					return ["M", "MC", "C"]
				else:
					return []
			# 0 missionaries
			else: 
				if state[1]>=2:
					return ["C", "CC"]
				else:
					return ["C"]
		# boat is on the left side
		elif(state[2] == 0):
			# 3 missionaries
			if (state[0]==3):
				# 2 cannibals
				if(state[1]==2):
					return ["C"]
				else:
					return ["C","CC"]
			elif state[0]==2:
				if state[1]==2:
					return ["M","MC","C"]
				else:
					return []
			elif state[0]==1:
				if state[1]==1:
					return ["MM","M", "MC", "C", "CC"]
				else:
					return []
			else:
				if state[1]==3:
					return ["M","MM"]
				elif state[1]==2:
					return ["M","MM","MC","C"]
				else:
					return ["M","MM","MC","CC"]
		else:
			return None

	def result(self, state, action):
		state = list(state)
		# boat on right side
		if state[2]==1:
			# boat now on left side
			state[2]=0
			if action=="M":
				state[0]=state[0]-1
				state[3]=state[3]+1
			elif action=="MM":
				state[0]=state[0]-2
				state[3]=state[3]+2
			elif action=="MC":
				state[0]=state[0]-1
				state[3]=state[3]+1
				state[1]=state[1]-1
				state[4]=state[4]+1
			elif action=="C":
				state[1]=state[1]-1
				state[4]=state[4]+1
			else:
				state[1]=state[1]-2
				state[4]=state[4]+2
		# boat on left side
		else:
			state[2]=1
			if action=="M":
				state[0]=state[0]+1
				state[3]=state[3]-1
			elif action=="MM":
				state[0]=state[0]+2
				state[3]=state[3]-2
			elif action=="MC":
				state[0]=state[0]+1
				state[3]=state[3]-1
				state[1]=state[1]+1
				state[4]=state[4]-1
			elif action=="C":
				state[1]=state[1]+1
				state[4]=state[4]-1
			else:
				state[1]=state[1]+2
				state[4]=state[4]-2
		state=tuple(state)
		self.state=state
		return self.state

	def h(self, node):
		return sum(s != g for (s, g) in zip(node.state, self.goal))

	# Check if current state is goal or not
	def goalTest(self, state):
		if state == self.goal:
			return True
		else:
			return False

def greedy_best_first_search(problem, h=None):
    """Greedy Best-first graph search is an informative searching algorithm with f(n) = h(n).
    You need to specify the h function when you call best_first_search, or
    else in your Problem subclass."""
    h = memoize(h or problem.h, 'h')
    node = best_first_graph_search(problem, lambda n: h(n))
    return(node)

def main():
	initial = [3,3,1,0,0]
	initial = tuple(initial)
	goal = [0,0,0,3,3]
	goal = tuple(goal)
	
	mc = MissionaryCannibal(initial, goal)
	#uniform cost
	uniformC = uniform_cost_search(mc)
	print("\nUniform-Cost Search")
	print("path size ",len(uniformC.path()))
	print("solution")
	print(uniformC.solution())
	for i in uniformC.path():
		print(i)
	#iterative deepening
	iterdeep = iterative_deepening_search(mc)
	print("\nIterative Deepening Search")
	print("path size ",len(iterdeep.path()))
	print("solution")
	print(iterdeep.solution())
	for i in iterdeep.path():
		print(i)
	#greedy best first search
	greedyBFS = greedy_best_first_search(mc)
	print("\nGreedy Best-First Search")
	print("path size ",len(greedyBFS.path()))
	print("solution")
	print(greedyBFS.solution())
	for i in greedyBFS.path():
		print(i)
	#A* search
	Astar = astar_search(mc)
	print("\nA* Search")
	print("path size ",len(Astar.path()))
	print("solution")
	print(Astar.solution())
	for i in Astar.path():
		print(i)
	#recursive best first search
	rbfs = recursive_best_first_search(mc)
	print("\nRBFS Search")
	print("path size ",len(rbfs.path()))
	print("solution")
	print(rbfs.solution())
	for i in rbfs.path():
		print(i)
	
main()
