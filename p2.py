# Mike Xie

## The missionary and cannibals problem is stated as follows. Three missionaries
## and three cannibals are on one side of the river, 
## along with a boat that can hold one or two people.
## find a way to get everyone to the other side
## without ever leaving a group of missionaries outnumbered by cannibals in that place


## formulate the search problem formally. State clearly how you represent states,
## (include the inital state and the goals state), what actions are available
## in each state, including the cost of each action.


## sketch a solution of the problem, show the path and its cost.
## describe the search strategy that you have used and motivate it

## implement search strategies in the AIMA code

## provide the path to the solution generated by your code
## uniform-cost search
## iterative deepening search
## greedy-best-first search
## A* search
## recursive best-first search


'''
Initial State
M3 M0
C3 C0
3 3 0 0
'''

'''
Goal State
M0 M3
C0 C3
0 0 3 3
'''

## Heurisitcs

# Manhattan Distance: - For this problem, Manhattan distance is defined as
# the distance of a tile from its global state
# for every missionary and cannibal that is out of place, it is the Manhattan distance
# the inital manhattan distance is 6. Since we start off with 3 Missionary and 3 Cannibals out of place

# The Heuristics for Missionary and Cannibal problem

from utils import *
from search import *


# problems will be solved with various search algorithms
class MissionaryCannibal(Problem):
	def __init__(self, initial, goal):
		Problem.__init__(self, initial, goal)
		self.state = initial
	def action(self, state):
		# list of possible actions
		# boat is on Right side
		if(state[2]==1):
			# if there are 3 missionaries on the right side
			if state[0]==3: 
				# if there are 2 or more cannibals on the right side
				if state[1]>=2:
				# possible actions
					return ["MM","M","MC","C","CC"]
				elif state[1]==1:
					return ["MM","M","MC","C"]
				# no cannibals
				else:
					return ["MM","M"]
			# 2 missionaries
			elif (state[0]==2):
				if state[1]==2:
					return ["MM","M","MC","C","CC"]
				else:
					return []
			# 1 missionaries
			elif (state[0]==1):
				if state[1]==1:
					return ["M", "MC", "C"]
				else:
					return []
			# 0 missionaries
			else: 
				if state[1]>=2:
					return ["C", "CC"]
				else:
					return ["C"]
		# boat is on the left side
		elif(state[2] == 0):
			# 3 missionaries
			if (state[0]==3):
				# 2 cannibals
				if(state[1]==2):
					return ["C"]
				else:
					return ["C","CC"]
			elif state[0]==2:
				if state[1]==2:
					return ["M","MC","C"]
				else:
					return []
			elif state[0]==1:
				if state[1]==1:
					return ["MM","M", "MC", "C", "CC"]
				else:
					return []
			else:
				if state[1]==3:
					return ["M","MM"]
				elif state[1]==2:
					return ["M","MM","MC","C"]
				else:
					return ["M","MM","MC","CC"]
		else:
			return None

	def result(self, state, action):
		state = list(state)
		# boat on right side
		if state[2]==1:
			# boat now on left side
			state[2]=0
			if action=="M":
				state[0]=state[0]-1
			elif action=="MM":
				state[0]=state[0]-2
			elif action=="MC":
				state[0]=state[0]-1
				state[1]=state[1]-1
			elif action=="C":
				state[1]=state[1]-1
			else:
				state[1]=state[1]-2
		# boat on left side
		else:
			state[2]=1
			if action=="M":
				state[0]=state[0]+1
			elif action=="MM":
				state[0]=state[0]+2
			elif action=="MC":
				state[0]=state[0]+1
				state[1]=state[1]+1
			elif action=="C":
				state[1]=state[1]+1
			else:
				state[1]=state[1]+2
		state=tuple(state)
		self.state=state
		return self.state

	# Check if current state is goal or not
	def goalTest(self, state):
		if state == self.goal:
			return True
		else:
			return False


def main():
	print("hi")
	initial = tuple([3,3,1])
	goal = tuple([0,0,0])
	
	mcproblem = MissionaryCannibal(initial, goal)
	#uniform cost
	#iterative deepening
	#greedy best first search
	#A* search
	#recursive best first search
	s= uniform_cost_search(mcproblem)
	print(s.path())
	
main()
